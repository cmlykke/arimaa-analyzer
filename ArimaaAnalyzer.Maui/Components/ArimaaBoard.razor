@using ArimaaAnalyzer.Maui.Services.Arimaa
@using ArimaaAnalyzer.Maui.Components
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@inject IJSRuntime JS

@{ 
    // Define a fixed outer size based on settings (8 squares * SquareSizePx)
    var outerSizePx = (int)(EffectiveSettings.SquareSizePx * 8);
    // Define a fixed inner size. When outer UI is shown, use the pre-calculated
    // InnerSquareSizePx so there is a consistent margin for the side buttons.
    var innerSizePx = (int)((EffectiveShowOuterUi ? EffectiveSettings.InnerSquareSizePx : EffectiveSettings.SquareSizePx) * 8);
}

<div class="board-outer @(EffectiveShowOuterUi ? "outer-ui-on" : "outer-ui-off")"
     style="--outer-size:@(outerSizePx)px; --inner-size:@(innerSizePx)px;">
    @if (EffectiveShowOuterUi)
    {
        <div class="outer-top">
            <button class="outer-btn outer-icon"
                    title="Previous turn"
                    aria-label="Previous turn"
                    disabled="@(!Game.CanPrev)"
                    @onclick="() => { Game.GoPrev(); StateHasChanged(); }">◀</button>

            <button class="outer-btn"
                    title="Commit move as variation"
                    aria-label="Commit move"
                    disabled="@(!Game.CanCommitMove)"
                    @onclick="() => { if (Game.CommitMove()) { StateHasChanged(); } }">Move</button>

            <button class="outer-btn outer-icon"
                    title="Next turn"
                    aria-label="Next turn"
                    disabled="@(!Game.CanNext)"
                    @onclick="() => { Game.GoNextMainLine(); StateHasChanged(); }">▶</button>
        </div>
    }

    <div class="outer-main">
        @if (EffectiveShowOuterUi)
        {
            <div class="outer-left">
                <button class="outer-btn outer-icon"
                        title="Rotate"
                        aria-label="Rotate"
                        @onclick="() => { Game.RotateBoardClockwise(); StateHasChanged(); }">Rt</button>

                <button class="outer-btn"
                        title="Reset pending moves"
                        aria-label="Reset pending moves"
                        disabled="@(!Game.CanResetPendingMoves)"
                        @onclick="() => { Game.ResetPendingMoves(); StateHasChanged(); }">Reset</button>
            </div>
        }

        <div class="board-inner" style="--piece-size:@(EffectiveSettings.PieceSizePx)px;">
            @for (var r = 0; r < 8; r++)
            {
                <div class="rank">
                    @for (var c = 0; c < 8; c++)
                    {
                        var pos = new Position(r, c);
                        var piece = Game.State.GetPiece(pos);
                        // Arimaa traps: only C3, F3, C6, F6 should be dark.
                        // With 0-based indices, columns A..H -> 0..7, rows top(8)..bottom(1) -> 0..7
                        // So C3 -> (row 5, col 2), F3 -> (5,5), C6 -> (2,2), F6 -> (2,5)
                        var isDark = (r == 2 || r == 5) && (c == 2 || c == 5);
                        var isSelected = _selectedPos == pos;
                        <div class="square @(isDark ? "dark" : "light") @(isSelected ? "selected" : "")"
                             data-row="@r"
                             data-col="@c"
                             @onpointerup="async (e) => await OnPointerUp(e)">
                            @if (piece is not null)
                            {
                                <img src="@($"pieces/{piece.SvgFileName}")"
                                     alt="@($"{piece.Side} {piece.Type}")"
                                     draggable="false"
                                     title="@(EffectiveBehavior.IsInteractive ? "Drag to move" : "")"
                                     @onpointerdown="() => OnDragStart(pos)"
                                />
                            }
                        </div>
                    }
                </div>
            }
        </div>

        @if (EffectiveShowOuterUi)
        {
            <div class="outer-right">
                <button disabled class="outer-btn outer-icon" title="Options" aria-label="Options">O</button>
            </div>
        }
    </div>

    @if (EffectiveShowOuterUi)
    {
        <div class="outer-bottom">
            <span class="outer-caption" title="@CurrentTurnCaption">@CurrentTurnCaption</span>
        </div>
    }
</div>

@code {
    // New preferred parameter name
    [Parameter]
    public ArimaaBoardSettings? BoardSettings { get; set; }

    // Back-compat alias; if both provided, BoardSettings wins
    [Parameter]
    public ArimaaBoardSettings? Settings { get; set; }

    [Parameter]
    public BoardBehavior Behavior { get; set; } = BoardBehavior.Playable;

    [Parameter]
    [EditorRequired]
    public ArimaaGameService Game { get; set; } = default!;

    private Position? _selectedPos;

    private ArimaaBoardSettings EffectiveSettings => BoardSettings ?? Settings ?? ArimaaBoardSettings.Default;
    private BoardBehavior EffectiveBehavior => (EffectiveSettings?.Behavior) ?? Behavior;
    private bool EffectiveShowOuterUi => (EffectiveSettings?.ShowOuterUi) ?? Game.ShowOuterUi;

    protected override void OnInitialized()
    {
        // Keep the board in sync when the game state or current node changes elsewhere (e.g., from GameTurnChildren)
        if (Game is not null)
        {
            Game.StateChanged += OnGameChanged;
            Game.CurrentNodeChanged += OnGameChanged;
        }
    }

    private void OnGameChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        if (Game is not null)
        {
            Game.StateChanged -= OnGameChanged;
            Game.CurrentNodeChanged -= OnGameChanged;
        }
    }

    private void OnDragStart(Position from)
    {
        if (!EffectiveBehavior.IsInteractive) return;

        // Only start a drag if there's a piece on the square
        if (Game.State.GetPiece(from) is not null)
        {
            _selectedPos = from;
        }
    }

    
    private async Task OnPointerUp(PointerEventArgs e)
    {
        if (_selectedPos is { } from)
        {
            // Use JS to find the actual square under the pointer.
            // This works for both Windows (normal events) and Android (captured events).
            var coords = await JS.InvokeAsync<int[]?>("getBoardSquare", e.ClientX, e.ClientY);

            if (coords is not null && coords.Length == 2)
            {
                var target = new Position(coords[0], coords[1]);

                // If we released on the same square we started/selected:
                // It's either a Tap (select) or a "move to self".
                // We keep the selection active so the user can tap a destination next.
                if (from == target)
                {
                    return;
                }

                // Otherwise, it's a Drag-and-Drop or the second step of a Tap-Tap
                Game.TryMove(from, target);
            }
        }
        _selectedPos = null;
    }

    // Displays the move number and the moves that led to the current position
    // Example: "12 Rc3n Hb4e". Falls back to "UI" when no node is loaded.
    private string CurrentTurnCaption
        => Game?.CurrentNode is { } node
            ? ($"{node.MoveNumber} {string.Join(" ", node.Moves ?? System.Array.Empty<string>())}" ).Trim()
            : "UI";
}
