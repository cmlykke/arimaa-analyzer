

2025-12-15
The current i dea of inferring all four moves from too statesis not practical.
instead, change the code so each time  a piece is picked up and placed again, 
a list will be filled with a new AEI,
and then the code will infer each step one at a time.
then update the tests.

-- 1 - create a new UI element that writes the current Move



2025-12-06

- A utility translation service must be created
it must be calculate this:
* all the "GameState"string from "graphic board" (make sure to replace the ones already made)
* calculate "GameState"string from game history 

- ArimaaGameService should be split into a service and a ArimaaGameModel
- A Model host hold this data:
metadata about the game
a grow-able tree structure with nodes.
each node must have this:
* a game move that shows how the game "got to this place"
* a calculated GameState object, based on the sibling move and the previus moves
* an enum that shows if the state is 
A: a cannonical move from a loaded game
B: a user attempted move
C: an AI calculated move
- The ArimaaGameService should be able to do this:
* verify a new game copy pasted into the field.
* calculate a finished ArimaaGameModel object from the game
this means it also has to be able to calculate a gameState string from a game history.

- a ArimmaBoard should be able to take either a single GameState or a ArimaaGameModel obejct

2025-12-04

||||--to be done to improve move validation
in CorrectMoveService and GameState needs to be changed. 
so game state is only saved as a single String, and not nested lists of SVG. references.

|||in CorrectMoveService, create a function that 
takes a state and a move, and checks if a capture should take place.
create it, by asking the Ai to extract the code needed for 
checking capture.

|||in CorrectMoveService, implement push pull.

ask the AI if more is needed than push pull.

-- make the inner and outer board parimiters adjust to eachother,
such that the output board size is as if the inner board was 9x9.

--create a section next to the main board 
on Android horizontal: the section should be below the board
on android vertical: the section should be to the right of the board.
on windows: the section should be to the right of the board.

--make sure it is possible to add boards to this section and 
that they will resize themselves, due to the smaller size.

--create a parameter class that can be passed to a ArimaaGameService. 
the first parameter to add will tell the board how big it should be. (outer board size).
the second parameter to add, will add a button that asks for analysis.




2025-11-24

On the board, pieces can now 
be dragged and dropped to any vanct square.

Board behavior can be changed through 
a BoardBehavior parameter class.

- create buttons that
reset a board position,
and a button that confirms the 
board position.

- make sure that the board 
uses the ArimaaEngineInterface 
sytax to save the currenct board position.

- Change the board position 
from a string to a tree structure that,
 to begin with,
perhaps should only have one branch 
per node. 

- toggle an enable/disable 
AI analysis toggle, that 
sends the poard position 
to the Ai, and sets the new board 
position according to the Ai.
This means that the board 
tree structure should tell the user that
the current board position is
an Ai position.